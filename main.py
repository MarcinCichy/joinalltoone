# FILE: JoinAllToOne/main.py

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_join_all_files.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
import sys
import json
from pathlib import Path
import fnmatch  # może być nieużywane, ale zostawiam jak było
# import magic

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QMessageBox

# Upewnij się, że te pliki są w tym samym katalogu co main.py
from OpenFileDialog import OpenFileDialog
from OpenDirectoryDialog import OpenDirectoryDialog
from SaveFileDialog import SaveFileDialog


class Ui_MainWindow(object):
    # --- POCZĄTEK MODYFIKACJI ---
    # Dodano puste definicje nowych metod, aby uniknąć błędów
    def auto_search_files(self):
        pass

    # --- KONIEC MODYFIKACJI ---

    def clear_list_of_files(self):
        pass

    def join_files(self):
        pass

    def open_file_dialog(self):
        pass

    def open_directory_dialog(self):
        pass

    def on_item_clicked(self, item):
        pass

    def check_all(self):
        pass

    def uncheck_all(self):
        pass

    def update_files(self):
        pass

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(943, 535)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMaximumSize(QtCore.QSize(943, 535))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setGeometry(QtCore.QRect(10, 10, 611, 471))
        self.groupBox_2.setObjectName("groupBox_2")
        self.textEdit = QtWidgets.QTextEdit(self.groupBox_2)
        self.textEdit.setGeometry(QtCore.QRect(10, 30, 571, 421))
        self.textEdit.setObjectName("textEdit")
        self.groupBox_3 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_3.setGeometry(QtCore.QRect(640, 10, 281, 471))
        self.groupBox_3.setObjectName("groupBox_3")
        self.listWidget = QtWidgets.QListWidget(self.groupBox_3)
        self.listWidget.setGeometry(QtCore.QRect(10, 30, 251, 431))
        self.listWidget.setObjectName("listWidget")
        self.pushButton_SelectFiles = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_SelectFiles.setGeometry(QtCore.QRect(640, 500, 65, 23))
        self.pushButton_SelectFiles.setObjectName("pushButton_SelectFiles")
        self.pushButton_JOIN = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_JOIN.setGeometry(QtCore.QRect(10, 500, 91, 21))
        self.pushButton_JOIN.setObjectName("pushButton_JOIN")
        self.pushButton_Clear = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Clear.setGeometry(QtCore.QRect(862, 500, 60, 23))
        self.pushButton_Clear.setObjectName("pushButton_Clear")
        # ——— nowe przyciski ———
        self.pushButton_checkAll = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_checkAll.setGeometry(QtCore.QRect(715, 500, 65, 23))
        self.pushButton_checkAll.setObjectName("pushButton_checkAll")

        self.pushButton_uncheckAll = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_uncheckAll.setGeometry(QtCore.QRect(790, 500, 65, 23))
        self.pushButton_uncheckAll.setObjectName("pushButton_uncheckAll")
        # ——————————————————
        self.pushButton_Update = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_Update.setGeometry(QtCore.QRect(560, 500, 65, 23))
        self.pushButton_Update.setObjectName("pushButton_Update")

        self.pushButton_MainFolder = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_MainFolder.setGeometry(QtCore.QRect(250, 500, 75, 23))
        self.pushButton_MainFolder.setObjectName("pushButton_MainFolder")

        # --- POCZĄTEK MODYFIKACJI: Dodanie nowego przycisku Auto Search ---
        self.pushButton_AutoSearch = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_AutoSearch.setGeometry(QtCore.QRect(335, 500, 85, 23))
        self.pushButton_AutoSearch.setObjectName("pushButton_AutoSearch")
        # --- KONIEC MODYFIKACJI ---

        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(120, 500, 111, 18))
        self.checkBox.setObjectName("checkBox")
        self.label_main_directory = QtWidgets.QLabel(self.centralwidget)
        self.label_main_directory.setGeometry(QtCore.QRect(430, 500, 120, 23))
        self.label_main_directory.setVisible(False)
        MainWindow.setCentralWidget(self.centralwidget)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        #  signals, sockets and connections
        self.pushButton_SelectFiles.clicked.connect(self.open_file_dialog)
        self.pushButton_JOIN.clicked.connect(self.join_files)
        self.pushButton_Clear.clicked.connect(self.clear_list_of_files)
        self.pushButton_Update.clicked.connect(self.update_files)
        self.pushButton_MainFolder.clicked.connect(self.open_directory_dialog)

        # --- POCZĄTEK MODYFIKACJI: Podłączenie sygnału dla nowego przycisku ---
        self.pushButton_AutoSearch.clicked.connect(self.auto_search_files)
        # --- KONIEC MODYFIKACJI ---

        self.pushButton_checkAll.clicked.connect(self.check_all)
        self.pushButton_uncheckAll.clicked.connect(self.uncheck_all)
        self.listWidget.itemClicked.connect(self.on_item_clicked)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Join All Files To One"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Joined All Files"))
        self.groupBox_3.setTitle(_translate("MainWindow", "Files to Select"))
        self.pushButton_SelectFiles.setText(_translate("MainWindow", "Select Files"))
        self.pushButton_JOIN.setText(_translate("MainWindow", "JOIN"))
        self.pushButton_Clear.setText(_translate("MainWindow", "Clear"))
        self.pushButton_checkAll.setText(_translate("MainWindow", "Check All"))
        self.pushButton_uncheckAll.setText(_translate("MainWindow", "Uncheck All"))
        self.pushButton_Update.setText(_translate("MainWindow", "Update"))
        self.pushButton_MainFolder.setText(_translate("MainWindow", "Main Folder"))

        # --- POCZĄTEK MODYFIKACJI: Ustawienie tekstu dla nowego przycisku ---
        self.pushButton_AutoSearch.setText(_translate("MainWindow", "Auto Search"))
        # --- KONIEC MODYFIKACJI ---

        self.checkBox.setText(_translate("MainWindow", "with layout"))


class FilesJoiner(Ui_MainWindow):
    """
    A class to combine multiple source code files into one file, as follows:
    ====================
    FILE: file name

    file content

    ====================
    FILE: name of the next file

    content of the next file
    """

    def __init__(self):
        super().__init__()
        self.status_item = {}
        self.all_files_content = {}
        # --- POCZĄTEK MODYFIKACJI: Aktualizacja typów plików i dodanie ścieżki do katalogu ---
        self.file_types = ['py', 'html', 'js', 'css', 'txt', 'layout']
        self.main_directory = ''
        self.main_directory_path = ''  # Przechowuje pełną ścieżkę do głównego folderu
        # --- KONIEC MODYFIKACJI ---

    def open_file_dialog(self):
        self.textEdit.clear()
        dlg = OpenFileDialog()
        file_paths = dlg.get_file_path(self.file_types)

        for file_path in file_paths:
            file_name = Path(file_path).name
            suffix = Path(file_name).suffix.lower()

            if suffix == '.layout':
                self.clear_list_of_files()
                self.all_files_content = self.read_files_layout(file_path)
                for fn in self.all_files_content.keys():
                    self.status_item[fn] = bool(self.all_files_content[fn]['content'])
                self.show_file_content()
                continue

            if suffix.lstrip('.') not in self.file_types:
                continue

            self.all_files_content[file_name] = {'path': file_path, 'content': []}
            item = QtWidgets.QListWidgetItem(file_name)
            item.setIcon(QIcon("red_checkmark.png"))
            self.status_item[file_name] = False
            self.listWidget.addItem(item)

    # --- POCZĄTEK MODYFIKACJI: Zmieniona metoda open_directory_dialog ---
    def open_directory_dialog(self):
        dlg = OpenDirectoryDialog()
        directory_path = dlg.get_directory_path()  # Otrzymuje pełną ścieżkę
        if directory_path:
            self.main_directory_path = directory_path
            self.main_directory = Path(directory_path).name
            self.label_main_directory.setVisible(True)
            self.label_main_directory.setText(self.main_directory)

    # --- KONIEC MODYFIKACJI ---

    # --- POCZĄTEK MODYFIKACJI: NOWA WERSJA auto_search_files ---
    def auto_search_files(self):
        """
        Przeszukuje wybrany katalog główny w poszukiwaniu plików o określonych rozszerzeniach
        i dodaje je do listy, z pominięciem katalogów wirtualnych środowisk, node_modules itd.
        """
        if not self.main_directory_path:
            self.show_message("Najpierw wybierz katalog główny za pomocą przycisku 'Main Folder'.")
            return

        self.clear_list_of_files()

        search_extensions = ['.py', '.html', '.js', '.css', '.txt', '.sql', '.iss', '.md']

        # nazwy katalogów, które wycinamy „po nazwie”
        excluded_dirs_exact = {
            '.git',
            '__pycache__',
            'node_modules',
            '.idea',
            '.vscode',
            'build',
            'dist',
            'builder',
        }

        # katalogi, które mają być wycinane po prefiksie
        # (czyli: .venv, .venv1, .venv_coś, venv, venv1, venv_coś)
        excluded_dirs_prefixes = ('.venv', 'venv')

        for root, dirs, files in os.walk(self.main_directory_path, topdown=True):
            # zachowaj oryginalną listę katalogów, z której będziemy wybierać
            original_dirs = list(dirs)
            dirs[:] = []  # wyczyść listę, będziemy dodawać tylko te dozwolone

            for d in original_dirs:
                name = d.lower()

                # 1) wytnij dokładnie znane katalogi
                if name in excluded_dirs_exact:
                    continue

                # 2) wytnij wszystko, co zaczyna się od .venv lub venv
                if any(name.startswith(prefix) for prefix in excluded_dirs_prefixes):
                    continue

                # jeżeli nie wycięliśmy – zostaje do przeszukiwania
                dirs.append(d)

            # teraz przetwarzamy pliki tylko w dozwolonych katalogach
            for file in files:
                file_path = Path(root) / file
                if file_path.suffix.lower() in search_extensions:
                    # Użyj ścieżki względnej jako unikalnego identyfikatora i etykiety
                    relative_path = file_path.relative_to(self.main_directory_path).as_posix()

                    if relative_path in self.all_files_content:
                        continue  # Pomiń jeśli już istnieje

                    self.all_files_content[relative_path] = {'path': str(file_path), 'content': []}
                    item = QtWidgets.QListWidgetItem(relative_path)
                    item.setIcon(QIcon("red_checkmark.png"))
                    self.status_item[relative_path] = False
                    self.listWidget.addItem(item)

    # --- KONIEC MODYFIKACJI ---

    def on_item_clicked(self, item):
        icon_paths = ("green_checkmark.png", "red_checkmark.png")
        new_status = not self.status_item.get(item.text(), False)
        self.status_item[item.text()] = new_status
        self.change_icon(item, new_status, *icon_paths)

        if new_status:
            self.load_file_content(item)  # teraz nie będzie drugi raz czytać tego samego pliku
        else:
            self.all_files_content[item.text()]['content'] = []
        self.show_file_content()

    def change_icon(self, item, status, icon_path_true, icon_path_false):
        try:
            item.setIcon(QIcon(icon_path_true if status else icon_path_false))
        except Exception as e:
            print(f"Error  loading icons: {str(e)}")
            self.show_message(str(e))

    def load_file_content(self, item, force=False):
        try:
            data = self.all_files_content[item.text()]

            # jeśli już mamy zawartość i nie wymuszamy odświeżenia – nic nie rób
            if data['content'] and not force:
                return

            # --- POPRAWKA: Próba odczytu z różnymi kodowaniami ---
            # Dzięki temu unikamy błędu przy plikach UTF-16 lub Windows-1250
            encodings_to_try = ['utf-8', 'utf-16', 'cp1250', 'latin-1']
            success = False

            for enc in encodings_to_try:
                try:
                    with open(data['path'], 'r', encoding=enc) as file:
                        data['content'] = file.readlines()
                    success = True
                    break
                except UnicodeDecodeError:
                    continue
                except Exception as e:
                    # Inne błędy niż kodowanie nadal chcemy widzieć
                    raise e

            # Fallback - jeśli nic nie zadziałało, otwórz z błędami jako 'replace'
            if not success:
                with open(data['path'], 'r', encoding='utf-8', errors='replace') as file:
                    data['content'] = file.readlines()
            # --- KONIEC POPRAWKI ---

        except Exception as e:
            print(f"Error reading file: {str(e)}")
            self.show_message(str(e))

    def show_file_content(self):
        # budujemy cały tekst w pamięci
        parts = []

        for fn, fc in self.all_files_content.items():
            if fc['content']:
                full_path = fc['path']
                shorten_path = self.shorten_path(full_path, self.main_directory)
                parts.append("==================== \n")
                parts.append(f"FILE: {shorten_path} \n\n")
                parts.append(''.join(fc['content']))
                parts.append('\n\n')

        # i dopiero na końcu ustawiamy zawartość w QTextEdit
        self.textEdit.setUpdatesEnabled(False)
        self.textEdit.setPlainText(''.join(parts))
        self.textEdit.setUpdatesEnabled(True)

    def join_files(self):
        joined_text = ''
        for fn, fc in self.all_files_content.items():
            if fc['content']:
                full_path = fc['path']
                shorten_path = self.shorten_path(full_path, self.main_directory)
                joined_text += f"==================== \nFILE: {shorten_path} \n\n{''.join(fc['content'])}\n\n"

        dlg = SaveFileDialog()
        if self.checkBox.isChecked():
            dlg.set_file_path(joined_text, self.all_files_content)
        else:
            dlg.set_file_path(joined_text, None)

    def clear_list_of_files(self):
        self.listWidget.clear()
        self.textEdit.clear()
        self.all_files_content = {}
        self.status_item = {}

    def check_all(self):
        self.listWidget.setUpdatesEnabled(False)

        for i in range(self.listWidget.count()):
            item = self.listWidget.item(i)
            if not self.status_item.get(item.text(), False):
                self.status_item[item.text()] = True
                self.change_icon(item, True, "green_checkmark.png", "red_checkmark.png")
                self.load_file_content(item)

        self.listWidget.setUpdatesEnabled(True)
        self.show_file_content()

    def uncheck_all(self):
        self.listWidget.setUpdatesEnabled(False)

        for i in range(self.listWidget.count()):
            item = self.listWidget.item(i)
            if self.status_item.get(item.text(), False):
                self.status_item[item.text()] = False
                self.change_icon(item, False, "green_checkmark.png", "red_checkmark.png")
                self.all_files_content[item.text()]['content'] = []

        self.listWidget.setUpdatesEnabled(True)
        self.show_file_content()

    def update_files(self):
        # ponowne wczytanie zawartości na dysku, zachowując status plików
        # --- POPRAWKA: Również tutaj dodajemy bezpieczne wczytywanie ---
        encodings_to_try = ['utf-8', 'utf-16', 'cp1250', 'latin-1']

        for fn, fc in self.all_files_content.items():
            path = fc['path']
            if self.status_item.get(fn, False):
                success = False
                try:
                    for enc in encodings_to_try:
                        try:
                            with open(path, 'r', encoding=enc) as f:
                                self.all_files_content[fn]['content'] = f.readlines()
                            success = True
                            break
                        except UnicodeDecodeError:
                            continue

                    if not success:
                        with open(path, 'r', encoding='utf-8', errors='replace') as f:
                            self.all_files_content[fn]['content'] = f.readlines()

                except Exception as e:
                    print(f"Error updating file: {e}")
                    self.show_message(str(e))
            else:
                self.all_files_content[fn]['content'] = []
        self.show_file_content()

    def read_files_layout(self, file_name):
        try:
            with open(file_name, 'r', encoding='utf-8') as file:
                files_layout = json.load(file)
        except Exception as e:
            print(f"Error reading file: {str(e)}")
            message = f"Error reading file: {str(e)}"
            self.show_message(message)

        for key in files_layout.keys():
            item = QtWidgets.QListWidgetItem(key)
            if files_layout[key]["content"]:
                item.setIcon(QIcon("green_checkmark.png"))
            else:
                item.setIcon(QIcon("red_checkmark.png"))
            self.listWidget.addItem(item)
        return files_layout

    def is_text_file(self, filename):
        ext = Path(filename).suffix.lower()
        if ext in ('.py', '.txt', '.json', '.html', '.css', '.layout'):
            return True
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                f.read(2048)
            return True
        except Exception:
            return False

    def show_message(self, message):
        msgbox = QMessageBox()
        msgbox.setIcon(QMessageBox.Warning)
        msgbox.setWindowTitle("Warning")
        msgbox.setText(message)
        msgbox.exec_()

    def shorten_path(self, full_path, directory_name):
        path_obj = Path(full_path)
        # Jeśli kluczem jest już ścieżka względna, po prostu ją zwróć
        if not path_obj.is_absolute():
            return path_obj.as_posix()

        path_parts = path_obj.parts
        try:
            # Znajdź indeks, gdzie zaczyna się ścieżka względna od katalogu głównego
            index = path_parts.index(directory_name)
            return Path(*path_parts[index:]).as_posix()
        except ValueError:
            # Jeśli nazwa katalogu nie zostanie znaleziona, zwróć ostatnią część ścieżki (nazwę pliku)
            return path_obj.name

    def get_absolute_path(self, relative_path):
        base_path = getattr(sys, '_MEIPASS', os.path.dirname(os.path.abspath(__file__)))
        return os.path.join(base_path, relative_path)


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = FilesJoiner()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())